LKrig.sim.conditional.foreach <- function(LKrigObj, M = 1, x.grid = NULL, 
    grid.list = NULL, nx = 80, ny = 80, ..., Z.grid = NULL, seed=42, verbose=FALSE,nCores=2) {
    
    require(doParallel)
    require(foreach)
    library(spam64)

    # generate grid if not specified
    if (is.null(x.grid)) {
        if (is.null(grid.list)) {
            grid.list <- fields.x.to.grid(LKrigObj$x, nx = nx, ny = ny)
        }
        x.grid <- make.surface.grid(grid.list)
    }
    if( verbose){
    	cat("LKrig.sim.conditional: x.grid")
    	print( x.grid)
    }
    # NOTE: the name x.grid may be misleading because it just needs to a column matrix of
    # locations. It need not follow any regular pattern.
    # now generate the error surfaces
    # begin block
    # create vector of seeds if needed
    if( length(seed)==1){
        seeds<- seed + ( 0:(M-1))
      }
    #
    g.conditional.draw <-    matrix(NA, ncol = M, nrow = nrow(x.grid))

    N <- nrow(LKrigObj$y)  
    # complete set of locations to evaluate the field must
    # include the observations too
    PHIGrid<- LKrig.basis(x.grid,LKrigObj$LKinfo) 
    if( verbose){
    	cat("LKrig.sim.conditional: dim(PHIGrid)",  dim(PHIGrid), fill=TRUE)
    }
   
    # predicted field at grid from the actual data
    spatialPart<- (PHIGrid%*% LKrigObj$c.coef)
    ghat <-  spatialPart
    if( !is.null(LKrigObj$LKinfo$fixedFunction) ){
      d.coef.draw<- matrix(NA, ncol = M, nrow = length( LKrigObj$d.coef) )
   } else{
   	d.coef.draw<- matrix(NA, ncol = M, nrow=1)
   	}
   	ghat<- predict( LKrigObj, x= x.grid, Z = Z.grid )


    # make a cluster and register it
    cl <- makeCluster(nCores)
    registerDoParallel(cl)

    simList <- foreach(k=1:M, .packages=c('LatticeKrig', 'spam64')) %dopar% simConditionalDraw( k, LKrigObj, ghat, x.grid, 
        Z.grid,  PHIGrid, seeds, ..., verbose=verbose)
  #       Z.grid,  PHIGrid, seeds, verbose=verbose)  # For testing purposes

    for(j in 1:M){
        if( !is.null(LKrigObj$LKinfo$fixedFunction) ){
            d.coef.draw[,j] <- simList[[j]]$d.coef
        }

        g.conditional.draw[, j] <- simList[[j]]$g.conditional
    }


    # Close up the cluster
    stopCluster(cl)


    return(list(x.grid = x.grid, ghat = ghat, g.draw = g.conditional.draw,
                           d.coef.draw= d.coef.draw))
}

simConditionalDraw <- function(index=1,  LKrigObj, ghat, x.grid, Z.grid, PHIGrid, seeds= 123,  verbose=FALSE){
require(LatticeKrig)
require(spam64)
        print(index)
        set.seed( seeds[index] )
# generate process at grid and also on the observation locations.
        simCoefficients<- LKrig.sim(LKinfo = LKrigObj$LKinfo, just.coefficients=TRUE)
        g.unconditional.data <-LKrigObj$wX %*%simCoefficients 
        g.unconditional.data <- sqrt(LKrigObj$rho.MLE) * g.unconditional.data
        g.unconditional.grid <-sqrt(LKrigObj$rho.MLE) *PHIGrid%*%simCoefficients 
        # generate a synthetic data set with fixed part set to zero.
        N<- length( LKrigObj$y)
        y.synthetic.data <- g.unconditional.data + LKrigObj$sigma.MLE * 
            rnorm(N)
# this may confusing. divide by  sqrt(weights) to cancel out this term in the
# wX matrix for  g.unconditional.data and to adjust measurement error variance         
        y.synthetic.data<- y.synthetic.data / sqrt(LKrigObj$weights)
        # use LKrig to find the predictions for the xgrid locations
        # NOTE that LKrig will still estimate the fixed part.
        # and it is important to include this part of estimate
        obj.fit.synthetic <- LKrig(LKrigObj$x, y.synthetic.data,
                                   LKinfo = LKrigObj$LKinfo,
                                       wX = LKrigObj$wX,
                                       wU = LKrigObj$wU,
                                   lambda = LKrigObj$lambda,
                                        Z = LKrigObj$Z,
                                  weights = LKrigObj$weights,
                             use.cholesky = LKrigObj$Mc)      
        #
        # predict field
        spatialPart<- (PHIGrid%*% obj.fit.synthetic$c.coef)
        ghat.synthetic<-  spatialPart
        if( !is.null(LKrigObj$LKinfo$fixedFunction) ){       	
                 fixedPart<- predict(
                 obj.fit.synthetic, xnew=x.grid, Znew = Z.grid, just.fixed=TRUE)
                 d.coef <- obj.fit.synthetic$d.coef
                 ghat.synthetic<- ghat.synthetic + fixedPart
         }
         else{
         	d.coef<- NA
         	}
         	
        # add prediction error to the condition mean from the actual data
        g.conditional <- ghat + (g.unconditional.grid -  ghat.synthetic)
        # NOTE: sampling variablity for fixed part is built in too
        # because d.coef are estimated and included in the prediction. 
return(
       list( g.conditional = g.conditional, d.coef = d.coef) )
}
